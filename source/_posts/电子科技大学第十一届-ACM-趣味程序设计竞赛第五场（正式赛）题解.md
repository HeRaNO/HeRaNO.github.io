---
title: 电子科技大学第十一届 ACM 趣味程序设计竞赛第五场（正式赛）题解
categories: 'OI/ICPC'
toc: true
date: 2019-12-07 17:00:00
tags:
	- 数学
	- 贪心
	- 模拟
	- 概率与期望
	- 欧拉路径
description: ' '
---

## A. Nico~ Nico~ Ni~
### 题目描述
给定一个字符串，问字符串中 `NicoNicoNi` 这个子串有多少个。

数据范围：$1\le |S|\le 10^5$。

### 题解
按题意模拟即可，按顺序每次取出长度为 $10$ 的子串，判断它是否为 `NicoNicoNi` 即可。

~~有没有写 KMP，AC 自动机，后缀数组，后缀自动机的童鞋啊。~~

时间复杂度：$\mathcal{O}(|S|)$，空间复杂度：$\mathcal{O}(|S|)$。

参考程序：[C++](https://github.com/HeRaNO/OI-ICPC-Codes/blob/master/UESTC/2317.cpp)，[Java](https://github.com/HeRaNO/OI-ICPC-Codes/blob/master/UESTC/2317.java)。

~~我曾经出过类似的题……~~

Problem Setter: Sugarii

## B. Help Fat_Dog Kill Bugs
### 题目描述
有 $n$ 个数 $a_i$。对于每个数，你可以给 $Y$ 加 $a_i$，或者给 $X$ 减 $a_i$。求最终 $Y^2-X^2$ 的最大值。

数据范围：$1\le n\le 10^4,0<X\le Y\le 100$。

### 题解
结论是，把这 $n$ 个数全部加给 $Y$，最后 $Y^2-X^2$ 是最大的。

考虑我们给 $Y$ 加了 $a$，给 $X$ 减了 $b$。那么 $a,b\ge 0$ 且 $a+b=\sum_{i=1}^n a_i$。最后答案变为 $(Y+a)^2-(X-b)^2$，化简整理为 $Y^2-X^2+2Ya+2Xb+a^2-b^2$。

考虑到 $\sum_{i=1}^n a_i$ 为一个定值，不妨设 $k=\sum_{i=1}^n a_i$。那么 $b=k-a$。由于要使得 $Y^2-X^2+2Ya+2Xb+a^2-b^2$ 这个值最大，$Y^2-X^2$ 为定值，因此目标要使得 $2Ya+2Xb+a^2-b^2$ 最大。代入 $b=k-a$，得到 $2(k-X+Y)a+2kX-k^2$，我们即要使这个式子的值最大。首先观察得这个是关于 $a$ 的一次函数，由于 $Y\ge X$，那么斜率一定是正数，那么最大值点就出现在定义域的最右端。即 $a=k$ 时这个式子的值最大。至此我们证明了前面贪心的策略是正确的。

需要注意数据范围和数据类型的使用。

时间复杂度：$\mathcal{O}(n)$，空间复杂度：$\mathcal{O}(1)$。

参考程序：[C++](https://github.com/HeRaNO/OI-ICPC-Codes/blob/master/UESTC/2323.cpp)，[Java](https://github.com/HeRaNO/OI-ICPC-Codes/blob/master/UESTC/2323.java)。

Problem Setter: Kaiser

## C. Expected Score
### 题目描述
有 $n$ 个数 $a_i$。每次可以均匀随机选一个除了最后一个位置之外的位置，把这个位置的值改为这个位置的值与后一个位置的值之差，然后把后一个位置的数删去。这个过程一直进行，直到整个数列就剩一个数。求剩下的这个数的期望大小。

数据范围：$n\ge 2$。

### 题解
结论是，$E(X)=a_1-a_2$。

考虑这个过程进行到倒数第二步，即序列只剩下两个数的时候。可以发现，除了前两个数，后面的数对于每种情况正负出现次数相等。也就是说，对于 $3\le i\le n$，对最后期望的贡献 $F(a_i)=-F(-a_i)$，所以在计算期望的时候，后面的数没有贡献。第一个数的贡献恒正，第二个数由于在最后一步被减掉，所以贡献恒负。因此有之前的结论。

下面是出题人给出的关于 $i\ge 3$ 的元素贡献为 $0$ 的证明：

由于取数对是随机的，那么第一轮取数取到 $a_i,a_{i+1}$ 与取到 $a_{i+1},a_{i+2}$ 的概率是相等的。

那么经过操作后，组成的序列为 $a_1,a_2,\ldots ,a_i-a_{i+1},a_{i+2},\ldots ,a_n$ 与 $a_1,a_2,\ldots ,a_i,a_{i+1}-a_{i+2},\ldots ,a_n$ 的概率是相等的。我们记前者为 (1) 式，后者为 (2) 式。

在第二次操作中，在 (1) 式中选择 $a_i-a_{i+1},a_{i+2}$ 与 在 (2) 式中选择 $a_i,a_{i+1}-a_{i+2}$ 的概率是相等的，我们记为 $p$。这两种选择对于答案的贡献为 $(a_i-a_{i+1}-a_{i+2})p+(a_i-a_{i+1}+a_{i+2})p=2p(a_i-a_{i+1})$，这也是区间 $[a_i,a_{i+2}]$ 的贡献。

类似区间 DP 的思想，我们可以合并这些小区间得到整个区间的情况。

这里不需要把 $n$ 个数全部输入进来。只需要读入前两个数即可。

时间复杂度：$\mathcal{O}(1)$，空间复杂度：$\mathcal{O}(1)$。

参考程序：[C++](https://github.com/HeRaNO/OI-ICPC-Codes/blob/master/UESTC/2321.cpp)，[Java](https://github.com/HeRaNO/OI-ICPC-Codes/blob/master/UESTC/2321.java)。

Problem Setter: fatdog_jo

## D. Linear Algebra
### 题目描述
给了 $n$ 个矩阵，他们重新排列之后一定能乘起来。问重新排列后乘起来，这个矩阵的最大可能大小。

数据范围：$1\le n\le 10^5,1\le x_i,y_i\le 100$。

### 题解
如果我们把重新排列之后的矩阵大小写成一排，大概类似于下面的形式：

$$
a_1\times a_2,a_2\times a_3,\ldots ,a_{n}\times a_{n+1}
$$

可以看出，这是一个从 $a_1$ 出发到 $a_{n+1}$ 的一条欧拉通路。欧拉通路是指从起点出发，经过边均不同到达终点的一条简单路径，也就是「一笔画问题」。

对于求解这样的问题，如果学过图论的话就可以很轻松地用一些判定定理进行判断。性质是：统计每个 $x_i,y_i$ 的出现次数，则按题目保证，一定没有或只有两个次数为奇数。如果没有次数为奇数，则输出出现次数不为 $0$ 对应的大小的平方，否则输出两个出现次数为奇数的大小的乘积。

证明比较简单，观察前面的序列，除了 $a_1$ 和 $a_{n+1}$，其余数都出现了偶数次，如果 $a_1=a_{n+1}$，那么就对应上述情况的第一种，否则对应第二种。

时间复杂度：$\mathcal{O}(n)$，空间复杂度：$\mathcal{O}(x)$。

参考程序：[C++](https://github.com/HeRaNO/OI-ICPC-Codes/blob/master/UESTC/2338.cpp)，[Java](https://github.com/HeRaNO/OI-ICPC-Codes/blob/master/UESTC/2338.java)。

Problem Setter: Macaron_lin

## E. Sugarii and String
### 题目描述
给了一个长度为 $n$ 的 $01$ 字符串，按照接下来的规则生成一个无限长度的字符串：

- 将自己复制一遍接到原字符串后面；
- 将复制过去的部分 $01$ 翻转，即 $1$ 变成 $0$，$0$ 变成 $1$。

询问这个无限字符串的第 $k$ 位是什么。

数据范围：$1\le n\le 10^5,1\le k\le 10^{18}$。

### 题解
首先我们考虑 $k$ 位置对应的原来的字符串的字符位置。虽然字符串以倍增方式增加，但是我们还是可以把无限字符串按长度为 $n$ 分块，每块要么与原字符串相同，要么 $01$ 是反转的。因此，可以计算出第 $k$ 个字符对应原字符串的第 $(k-1)\bmod n+1$ 个字符。

我们考虑这一块是和原字符串相同的还是翻转的。第 $k$ 个字符所在块为 $\lfloor \frac{k-1}{n}\rfloor +1$。记 $p$ 为第 $k$ 个字符所在块，并且在第 $i$ 次新生成的块中，那么 $2^{i-1}\le p\le 2^i$，我们将其减去 $2^{i-1}$，就知道了它是由之前的哪个块经 $01$ 翻转得到的。每次我们找到小于等于 $p$ 的最后一个二的幂次，然后每次让 $p$ 减去这个值，并记录一共翻转了多少次。直到 $p=0$ 时停止。

观察这个过程，其实我们减去的这个二的幂次是 $p$ 的二进制中所有等于 $1$ 的位。实际上，如果所在块编号从 $0$ 开始，块编号的二进制表示中 $1$ 为偶数个的话，这个块就与原字符串相同，否则 $01$ 互换。

因此，记块编号的二进制表示中 $1$ 为奇数个时 $p=1$，否则 $p=0$，答案就是字符串中第 $(k-1)\bmod n+1$ 个字符与 $p$ 的异或。

时间复杂度：$\mathcal{O}(n)$ 或 $\mathcal{O}(n+\log k)$，空间复杂度：$\mathcal{O}(n)$。

参考程序：[C++](https://github.com/HeRaNO/OI-ICPC-Codes/blob/master/UESTC/2313.cpp)，[Java](https://github.com/HeRaNO/OI-ICPC-Codes/blob/master/UESTC/2313.java)。

Problem Setter: cjj490168650

至此，电子科技大学第十一届 ACM 趣味程序设计竞赛就结束了。完结撒花~
