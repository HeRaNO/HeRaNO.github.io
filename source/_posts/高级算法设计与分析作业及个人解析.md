---
title: 高级算法设计与分析课后内容个人解析
date: 2023-03-23 16:08:26
categories: 'OI/ICPC'
toc: true
tags:
	- 贪心
	- 堆
	- DP
description: ' '
---

文章包含哈尔滨工业大学高级算法设计与分析课程作业、实验和大作业的个人解析。

四个实验可以参考[这里](https://github.com/HeRaNO/ChickenRibs/tree/master/AdvancedDesignAndAnalysisOfAlgorithm)。大作业可以选[分布式一致性 hash](https://en.wikipedia.org/wiki/Consistent_hashing)，问题不大，资料也比较多（毕竟上课和面试八股里都有），可以参考 Stanford [CS 168](https://web.stanford.edu/class/cs168/) 的 [Lecture 1](https://web.stanford.edu/class/cs168/l/l1.pdf)，讲义很清楚，里面有一致性 hash 的出处论文。PPT 自己做吧，还得录音，哈哈。

原来以为这个研究会发 SOSP 或者 SIGCOMM 这种，但是居然发的是理论的 STOC。

最 nb 的是作业要手写，哈哈，给助教磕一个吧。为了整这堆东西，Skyplane 论文看得磕磕巴巴，DuVisor 的博客来不及写，网络算法学也好几周没看，认真整这玩意真的就输了。

## 第一次作业

一、证明：$\log n!=\Theta(n\log n)$

设 $f(n)=\log n!$，$g(n)=n\log n$。

令 $c_1=1,n_{01}=1$，当 $n>n_{01}$ 时
$$
f(n)=\log n!=\log \prod_{i=1}^ni=\sum_{i=1}^n\log i\le \sum_{i=1}^n \log n=c_1n\log n
$$
所以 $f(n)=\mathcal{O}(n\log n)$。

由于
$$
n!=1\times 2\times \ldots\times n\ge \lceil\frac{n}{2}\rceil\times(\lceil\frac{n}{2}\rceil+1)\times \ldots\times n\ge \left(\frac{n}{2}\right)^{\frac{n}{2}}
$$
其中对第一个不等号，$1$ 到 $n$ 的乘积一定不小于舍去前 $\lceil\frac{n}{2}\rceil-1$ 项的乘积。对于第二个不等号，将左边的每一个数均替换为 $\frac{n}{2}$，结果一定不变大，左边式中共有 $n-\lceil\frac{n}{2}\rceil+1=\lceil\frac{n}{2}\rceil$ 项，因此同时将指数变小，结果一定不会变大。

所以
$$
f(n)=\log n!\ge \log\left(\frac{n}{2}\right)^{\frac{n}{2}}=\frac{n}{2}\log \frac{n}{2}=\frac{1}{2}n\log n-\frac{n}{2}\log 2
$$
令 $c_2=\frac{1}{4},n_{02}=4$，当 $n>n_{02}$ 时
$$
f(n)=\frac{1}{2}n\log n-\frac{n}{2}\log 2=\frac{1}{2}n\log n-\frac{1}{4}n\log 4\ge \frac{1}{2}n\log n-\frac{1}{4}n\log n=c_2n\log n
$$
所以 $f(n)=\Omega(n\log n)$。

从而 $f(n)=\Theta(n\log n)$。

二、用**迭代法**解递归方程：$T(n)=2T(n/2)+n\log n,T(1)=1$
$$
\begin{align}
T(n)&=2T(\frac{n}{2})+n\log n\\
&=2(2T(\frac{n}{4})+\frac{n}{2}\log \frac{n}{2})+n\log n\\
&=4T(\frac{n}{4})+n(\log n+\log \frac{n}{2})\\
&=2^iT(\frac{n}{2^i})+n(\log n+\log \frac{n}{2}+\ldots+\log \frac{n}{2^{i-1}})
\end{align}
$$
令 $\frac{n}{2^i}=1$，则 $i=\log_2 n$。

则有
$$
\begin{align}
T(n)&=2^iT(\frac{n}{2^i})+n(\log n+\log \frac{n}{2}+\ldots+\log \frac{n}{2^{i-1}})\\
&=2^{\log_2 n}T(1)+n\sum_{j=0}^{i-1}\log \frac{n}{2^j}\\
&\le n+n\sum_{j=0}^{i-1}\log n
=n\log^2n+n=\mathcal{O}(n\log^2 n)
\end{align}
$$
所以 $T(n)=\mathcal{O}(n\log^2 n)$。

三、求解递归式：$T(n)=\sqrt nT(\sqrt n)+n$
$$
\begin{align}
T(n)&=n^{\frac{1}{2}}T(n^{\frac{1}{2}})+n\\
&=n^{\frac{1}{2}}(n^{\frac{1}{4}}T(n^\frac{1}{4})+n^\frac{1}{2})+n\\
&=n^\frac{3}{4}T(n^\frac{1}{4})+2n\\
&=n^\frac{3}{4}(n^\frac{1}{8}T(n^\frac{1}{8})+n^\frac{1}{4})+2n\\
&=n^\frac{7}{8}T(n^\frac{1}{8})+3n\\
&=n^{1-\frac{1}{2^i}}T(n^\frac{1}{2^i})+in
\end{align}
$$
令 $n^{\frac{1}{2^i}}=2$，则 $i=\log\log n$，假设 $T(2)$ 为常数，则有
$$
T(n)=n^{1-\frac{1}{\log n}}T(2)+n\log\log n\le n+n\log\log n=\mathcal{O}(n\log\log n)
$$
所以 $T(n)=\mathcal{O}(n\log\log n)$。

四、求解递归式：$T(n)=T(\lfloor n/2\rfloor)+T(\lfloor 3n/4\rfloor)+n$

根据 Akra–Bazzi 定理
$$
a_1=a_2=1,b_1=\frac{1}{2},b_2=\frac{3}{4}\\
|g'(x)|=1\in\mathcal{O}(x^c)\\
|h_i(x)|=C\in \mathcal{O}\left(\frac{x}{\log^2 x}\right)
$$
该递推式满足定理适用条件，则
$$
\begin{align}
T(n)&=\Theta\left(n^p\left(1+\int_1^n \frac{g(x)}{x^{p+1}}\text{d}x\right)\right)\\
&=\Theta\left(n^p\left(1+\int_1^n \frac{x}{x^{p+1}}\text{d}x\right)\right)\\
&=\Theta\left(n^p\left(1+\int_1^n x^{-p}\text{d}x\right)\right)\\
&=\Theta\left(n^p\left(1+\frac{n^{1-p}}{1-p}-\frac{1}{1-p}\right)\right)\\
&=\Theta\left(n^p\right)\\
\end{align}
$$
其中 $(\frac{1}{2})^p+(\frac{3}{4})^p=1$，即 $p\approx1.507$。

即 $T(n)=\Theta(n^p)$，也可以称 $T(n)=\mathcal{O}(n^2)$。

五、求解递归式：$T(n)=2T(n/2)+n^{1/2}$，$T(n)=1$ 对 $n<4$ 成立

根据 Master 定理，$a=2,b=2,f(n)=n^{\frac{1}{2}}$。取 $\varepsilon=0.5$，则 $f(n)=\mathcal{O}(n^{\log_2 2-0.5})=\mathcal{O}(n^\frac{1}{2})$。所以满足第一条使用条件，$T(n)=\Theta(n)$。

六、根据表达式 $a^{2k}=a^k\cdot a^k$ 和 $a^{2k+1}=a^k\cdot a^k\cdot a$ 设计分治（或递归）算法求解下列问题，并分析算法的时间复杂度。

a\. 输入实数 $a$ 和自然数 $n$，输出实数 $a^n$；  
b\. 输入实数矩阵 $A$ 和自然数 $n$，输出实数矩阵 $A^n$。

a\. 递归伪代码如下：

```plain
Pow(a, n)
    if n = 0 then
        return 1
    if n = 1 then
        return a
    result := Pow(a, n / 2)
    if n mod 2 = 0 then
        return result * result
    else
        return a * result * result
    endif
```

可以写出递归式 $T(n)=T(\frac{n}{2})+\mathcal{O}(1)$，使用迭代求解可知此算法时间复杂度为 $\mathcal{O}(\log n)$。

b\. 递归伪代码如下：

```plain
PowMatrix(A, n)
    if n = 0 then
        return I
    if n = 1 then
        return A
    result := PowMatrix(A, n / 2)
    if n mod 2 = 0 then
        return result * result
    else
        return A * result * result
    endif
```

可以写出递归式 $T(n)=T(\frac{n}{2})+\mathcal{O}(m^3)$，其中 $m$ 为矩阵的规模。同样使用迭代求解可知时间复杂度为 $\mathcal{O}(m^3\log n)$。

七、给定平面上 $n$ 个点构成的集合 $S=\{p_1,\ldots, p_n\}$。如果存在边平行于坐标轴的矩形仅包含 $S$ 中的两个点 $p_i$ 和 $p_j\ (1 \le i, j \le n)$，则称 $p_i$ 和 $p_j$ 为「友谊 点对」。试设计一个分治算法统计 $S$ 中友谊点对的个数。

首先考虑对于一个「友谊点对」，一定存在一个以这个点对为对角线的矩形包含这个点对。对于这个缩小的矩形退化为一条线段的情况，那么我们可以给长（或宽）加上一个无穷小量保证其为一个矩形而满足题目要求。因此问题可以规约到统计满足下列条件的点对数量：

- 以这个点对为对角线的矩形内部或边界上（或退化成的线段上）没有其他点。

首先将所有点按 $x$ 坐标排序。之后针对 $y$ 坐标分治。分割过程如下：

1. 计算这些点中 $y$ 坐标的中位数 $m$；
2. 用水平线 $L:y=m$ 将点划分为两个集合。称为上半部分和下半部分；
3. 计算点对中两点分别在上半部分和下半部分的时候对答案的贡献；
4. 递归地计算上半部分和下半部分分别对答案的贡献。

对于边界情况，如果目前的点集为空集或只有一个点，则直接返回，如果只有两个点，则对答案有贡献 $1$。

对于计算贡献部分，由于点对中两点分别位于上半部分和下半部分，所以仅需考虑上半部分的点作为左上或右上，下半部分的点作为左下或右下的情况。

考虑上下两部分 $x$ 坐标均为递增顺序，如果选定上半部分的某一个点为右上角，那么下半部分所有 $x$ 坐标小于等于上半部分选定点的就在考虑范围中。考虑按照 $x$ 坐标递增的顺序枚举上半部分的每一个点，如果有 $x$ 坐标相同的情况，则只考虑 $y$ 坐标最小的那个，因为所有 $y$ 坐标比它大的点构成的矩形一定包含 $y$ 坐标最小的这个。令目前枚举到的上半部分点为 $A_l$，如果前一个点 $A_{l-1}$ 的 $y$ 坐标比 $A_l$ 小，那么我们需要考虑的下半部分点的 $x$ 坐标就要比 $A_{l-1}$ 的 $x$ 坐标大，否则如果下半部分考虑的 $x$ 范围不比 $A_{l-1}$ 的 $x$ 坐标大，则会存在矩形包含 $A_{l-1}$ 的情况，这样是不合法的；如果前一个点 $A_{l-1}$ 的 $y$ 坐标比 $A_l$ 大，那么这些 $y$ 坐标大的点不会进入以 $A_l$ 为右上角的矩形，下半部分考虑的 $x$ 范围就可以向左扩大到上半部分第一个 $y$ 坐标比 $A_l$ 小的点的 $x$ 坐标，所有比这个 $x$ 坐标大的点均在考虑范围中；如果前一个点 $A_{l-1}$ 的 $y$ 坐标等于 $A_l$ 的 $y$ 坐标，那么同样下半部分的 $x$ 坐标只考虑大于 $A_{l-1}$ 的 $x$ 坐标的部分。

所以，对于枚举到的点 $A_l$，我们需要找到它前面第一个 $y$ 坐标不大于它的点 $A_p$，如果称 $A_p$ 的 $x$ 坐标为 $x_p$，$A_l$ 的 $x$ 坐标为 $x_l$ 的话，我们需要考虑下半部分 $x$ 坐标在 $(x_p,x_l]$ 的点。我们希望快速找到这样的 $p$，因此对于上半部分可以维护一个 $y$ 坐标单调不减的栈。如果要加入的点 $y$ 坐标比栈顶小，则弹栈，直到要加入的点 $y$ 坐标大于等于栈顶的 $y$ 坐标。那么现在栈顶的 $x$ 坐标与要加入的点的 $x$ 坐标之间的区域就是下半部分要考虑的点。

对于下半部分，仍然按从左到右的顺序考虑，如果有 $x$ 坐标相同的情况，则只考虑 $y$ 坐标最大的那个，因为所有 $y$ 坐标比它小的点构成的矩形一定包含 $y$ 坐标最大的这个。考虑下半部分一个点如果对答案有贡献，当且仅当这个点之后没有 $y$ 坐标大于等于它的，由于如果这个点可以成为答案并且后面有一个点 $y$ 坐标大于等于它，那么这个点就会在答案形成的矩形中，不符合定义。由于按顺序考虑，如果下半部分的某个点对答案无贡献，那么在所有情况中这个点对答案都没有贡献。因此顺序考虑下半部分的点，维护 $y$ 坐标单调减的栈。如果要加入的点 $y$ 坐标大于等于栈顶，则弹栈，直到要加入的点 $y$ 坐标小于栈顶的 $y$ 坐标。枚举完成后，栈中剩余元素就是所有我们需要考虑的可能对答案有贡献的点。

之后，对于上层枚举到 $A_l$，前面第一个 $y$ 坐标不大于它的点为 $A_p$ 的情况，我们只需统计下半部分的栈中有多少点的 $x$ 坐标在 $(x_p,x_l]$ 区间内，使用二分法找出 $x$ 坐标第一个大于 $x_p$ 的位置和最后一个小于等于 $x_l$ 的位置即可。

综上，选定上半部分的某一个点为右上角的情况对答案的贡献已经处理完毕。选定上半部分的某一个点为左上角的情况与其类似，我们只需要将所有点沿 $y$ 轴对称，重复上述算法即可，考虑等价性，沿 $y$ 轴对称的点分布统计上半部分的某一个点为右上角的情况等价于原来点分布统计上半部分的某一个点为左上角的情况。

至此，第 3 步已经处理完毕。

考虑时间复杂度，我们按照 $y=m$ 这条水平线分割，但是有可能有许多点的 $y$ 坐标均为 $m$。当出现这种情况时，我们选择这些 $y$ 的样本中点进行上下部分分割。由于我们已经考虑了 $y$ 相同情况的处理，所以这样分割的正确性也可以保证。并且从样本中点分割可以保证分成的两个子问题大小均为 $\frac{n}{2}$，保证时间复杂度不会变差。

我们在考虑上半部分时，每个点会被枚举一次，并且由于出栈后的点不会在入栈，因此出入栈最多一次，在考虑下半部分时，同样每个点被枚举一次，出入栈最多一次。所以在处理上半部分的区间和下半部分对答案有贡献的点的时间复杂度为 $\mathcal{O}(n)$。对于统计答案，由于 $A_p$ 和 $A_l$ 相关，我们枚举了每个 $A_l$，并在下半部分的栈中进行二分。因此这部分时间复杂度为 $\mathcal{O}(\frac{n}{2}\log\frac{n}{2})$。因此可以写出递归式 $T(n)=2T(\frac{n}{2})+\mathcal{O}(\frac{n}{2}\log\frac{n}{2})$。使用迭代法求解，可知这个算法的时间复杂度为 $\mathcal{O}(n\log^2 n)$。

> 原题为 [JOISC 2014 稻草人](https://loj.ac/p/2880)，代码可以参考[这里](https://loj.ac/s/1722378)。只需要把点按 $y$ 轴对称就变成了这个题了。

八、输入含有 $n$ 个顶点的加权二叉树 $T$ 和正数 $\tau$，树 $T$ 上每条边的权值都非负，树中顶点 $x, y$ 的距离 $\text{dis}(x, y)$ 定义为从 $x$ 到 $y$ 的各边权值之和。试设计一个分治算法输出满足 $\text{dis}(x, y) \le \tau$ 的顶点对个数，并分析时间复杂度。

考虑对树进行点分治，定义一棵树的重心为如果以这个点为根，没有任何点的子树大小超过 $\frac{n}{2}$，其中 $n$ 为这棵树的节点个数。

考虑先找到一棵树的重心，将其分为一些子树。那么所有点对之间的路径就可以分为如下两种情况：

1. 点对之间路径完全在一个子树中；
2. 两点分别位于两不同子树（或其中一点为重心），易知这条路径一定过重心；

考虑情况 1，为原问题的一个子问题，首先找出其子树的重心，然后递归地调用该算法即可。对于找出一棵树的重心，可以先统计出这棵子树中每个节点以它为根时每棵子树大小，之后根据定义找到重心。我们可以类似前缀和地统计，对于「向上」的子树大小，为整棵树的大小减去以这个节点为根「向下」的所有子树大小之和。因此统计中树上节点全部被统计一次，时间复杂度为 $\mathcal{O}(n)$。

考虑情况 2，由于需要统计 $\text{dis}(x,y)\le \tau$ 且 $x,y$ 在不同子树的点对数量，而情况 2 中的路径一定过重心，那么 $\text{dis}(x,y)$ 就等于 $\text{dis}(x,G)+\text{dis}(y,G)$，其中 $G$ 为重心。那么要统计的值就等于这棵树中所有 $\text{dis}(x,G)+\text{dis}(y,G)\le \tau$ 的点对数量减去其中 $x,y$ 在同一子树的点对数量。

实际上两个问题性质相同，考虑如何统计 $\text{dis}(x,G)+\text{dis}(y,G)\le \tau$ 的点对数量。可以先统计以 $G$ 为根的子树中所有节点（包括 $G$）到 $G$ 的距离，记为 $d_i$。由此原问题转化为统计有多少无序数对 $(i,j)$，其中 $i\neq j$，使得 $d_i+d_j\le \tau$。相当于统计有多少有序数对 $(i,j)$，其中 $i<j$ 满足前述不等式。

考虑对 $d_i$ 排序，若我们枚举 $i$ 。由于单调性，在 $d_i$ 增大时要使和式小于 $\tau$，$j$ 不会向右移动。因此使用尺取法，每次 $i$ 枚举到下一个位置时，$j$ 随之向左调整到满足不等式的最右端位置。那么这次调整将为 $i$ 产生 $j-i$ 对满足条件的数对。当 $i\ge j$ 时，由于需要满足有序数对的要求，算法结束。

分析上述统计过程的时间复杂度，首先排序带来了 $\mathcal{O}(n\log n)$ 的复杂度。对于之后的统计，由于 $i$ 单调向右移动，$j$ 不动或始终向左移动，当 $i\ge j$ 时停止。这个过程中序列中每个元素最多访问一次。因此这个统计过程的复杂度是 $\mathcal{O}(n)$。综上，整体统计过程复杂度为 $\mathcal{O}(n\log n)$。

由于一条路径要么过重心，要么不过重心。在问题分解时情况已经考虑完全，子问题之间没有重复，因此算法正确性易得。

由于重心的子树没有任何点子树大小超过 $\frac{n}{2}$，那么最差情况为一条链。会将原问题分解为两个规模为 $\frac{n}{2}$ 的子问题。然后我们需要找出每个子树的重心，时间复杂度为 $\mathcal{O}(n)$。对于情况 2，已经分析出复杂度为 $\mathcal{O}(n\log n)$。综上时间复杂度可以写作递推式 $T(n)=2T(\frac{n}{2})+\mathcal{O}(n\log n)$，使用迭代法计算可知这种分治算法时间复杂度为 $\mathcal{O}(n\log^2 n)$。

> 点分治入门题，可以在[坟](https://blog.csdn.net/HeRaNO/article/details/73008506)里看。

九、给定平面上 $n$ 个点坐标 $(x, y)$ 构成的集合 $S=\{p_1,p_2,\ldots ,p_n\}$，$p_i=(x_i, y_i)$，$n \ge 3$，试设计一个分治算法，输出 $S$ 中的三个点，使得以这三个点为定点的三角形周长达到最小，并分析时间复杂度。

考虑使用与求平面最近点对类似的算法。假设目前要处理的点集 $Q$ 中点已经按照 $x$ 坐标从小到大排好序了。

如果 $Q$ 中有少于三个点，则直接退出。如果 $Q$ 中有三个点，如果这三个点可以构成三角形后返回这个三角形，同时将其按 $y$ 坐标从小到大排序。

否则，计算 $Q$ 中各点 $x$ 坐标中位数 $m$，用垂线 $L:x=m$ 将点集分为大小相等的左右两部分。并递归地在左右寻找周长最小的三角形。

令 $C_L$ 为左半部分周长最小三角形的周长，$C_R$ 为右半部分周长最小三角形的周长，记 $d=\min\{C_L,C_R\}$。合并左右两边时，可以知道合并的情况是左边贡献一个点，右边贡献两个点，或左边贡献两个点，右边贡献一个点。考虑在某边取一个点，假设这个点选在 $(-\infty,m-\frac{d}{2})\cup(m+\frac{d}{2},+\infty)$ 区间，我们无论第二个点选在哪里，这个三角形的周长均会大于 $d$。由于三角形两边之和大于第三边，这样选择点，总会使得三角形存在一条长度大于 $\frac{d}{2}$ 的边，使得周长超过 $d$。因此只需考虑横坐标在 $[m-\frac{d}{2},m+\frac{d}{2}]$ 区间内的点即可。

再基于同样考虑，选定了一个点 $i$，假设它的纵坐标为 $y_i$，我们只需考虑纵坐标在 $[y_i-\frac{d}{2},y_i+\frac{d}{2}]$ 的点作为第二和第三个点。此时左右部分 $y$ 坐标均按从小到大排序，按照归并排序的思路将左右两部分点按 $y$ 坐标二路归并。对于横坐标在考虑范围内的点，按纵坐标从小到大的顺序枚举选定点 $i$。如果确定了一个点 $i$ 就确定了一个考虑范围，由于按纵坐标从小到大的顺序枚举点 $i$，所以这个考虑区间只会向上移动，使用双指针框定考虑范围后暴力枚举第二和第三个点即可，判断其是否可以构成三角形后更新答案。

对于这部分复杂度，和最近点对同样采用画格法考虑，由于对于每一个 $i$，需要考虑的范围内点数为常数，那么其平方也为一常数。所以合并左右两部分求出这部分的答案的复杂度为 $\mathcal{O}(n)$。

综上，我们每步将问题分解成了两个规模为 $\frac{n}{2}$ 的子问题，同时对 $y$ 坐标归并排序，并更新答案的时间复杂度为 $\mathcal{O}(n)$。因此可以写出递归式 $T(n)=2T(\frac{n}{2})+\mathcal{O}(n)$，根据 Master 定理可知此算法时间复杂度为 $\mathcal{O}(n\log n)$。

> 原题来自 [BJWC 2011 最小三角形](https://www.luogu.com.cn/problem/P4423)，顺便重写了一下严格 $\mathcal{O}(n\log n)$ 的最近平面点对，在[这里](https://github.com/HeRaNO/OI-ICPC-Codes/blob/master/Template/CG/Template-for-Closest-Point-Pair.cpp)。注意做比较的时候距离是有平方的，水平和竖直方向上的距离求完坐标差之后要平方。

十、设 $A$ 是由不同实数组成的数组，如果 $i < j$ 且 $A_i > A_j$，则称实数对 $(A_i, A_j)$ 是该实数组的一个反序。如，若 $A = [3, 5, 2, 4]$，则该数组存在 $3$ 个反序 $(3, 2)$，$(5, 2)$ 和 $(5, 4)$。反序的个数可以用来衡量一个数组的无序程度。试设计一个时间复杂度严格低阶于 $n^2$ 的分治算法，计算给定数组的反序个数，并分析时间复杂度。

考虑归并排序的同时统计逆序对数量。首先将序列从中间分为两部分。即，对于序列 $a[l\ldots r]$，考虑分为 $a[l\ldots m]$ 和 $a[m+1\ldots r]$ 两部分。其中 $m=\frac{l+r}{2}$。

递归统计两个部分内部的逆序对数量并归并排序后，将左右两部分有序序列归并并统计左边对右边逆序对的影响。考虑二路归并时左边出现了一个大于右边的数，这就证明出现了逆序对。每次后段首元素被作为当前最小值取出时，前段所有剩余元素都会与这个元素形成一个逆序对，因此前段剩余元素个数即是后端首元素对逆序对的贡献。因此，分割后归并的同时统计逆序对数量即可。

对于分割部分，我们分割成了两个互不相交的子问题，二路归并中，所有元素均被访问一次，统计逆序对仅需要计算前段数组长度与现在前段的指针位置的差值，时间复杂度为 $\Theta(1)$，因此二路归并的复杂度为 $\Theta(n)$。

综上，可以写出递归式 $T(n)=2T(\frac{n}{2})+\Theta(n)$。使用主定理可以计算复杂度为 $\Theta(n\log n)$。此复杂度严格低阶于 $n^2$。

## 第二次作业

### 动态规划

一、设你要爬 $n$ 阶楼梯。 每一次，你可以爬 $1$ 个或者 $2$ 个台阶。计算总共有多少种方法可以爬完？如：$n=3$，则有三种，分别是 $1+1+1,1+2,2+1$。

1\. 证明该问题的优化子结构，说明子问题的重叠性。  
2\. 给出状态转移方程和初始条件，并写出伪代码。  
3\. 分析算法复杂度。

1\. 本问题为一计数问题而非优化问题。令现在我们位于第 $i$ 级台阶，若要一步登上第 $i$ 级台阶，那么要么是从第 $i-1$ 级台阶爬一步登上来的，要么是从第 $i-2$ 级台阶爬两步登上来的。根据分类加法计数原理，登上第 $i$ 级台阶的方案数取决于登上第 $i-1$ 级台阶的方案数与登上第 $i-2$ 级台阶的方案数。可以令 $f_i$ 表示登上第 $i$ 级台阶的方案数。子问题即为求出每个登上第 $i$ 级台阶的方案数。

2\. 由 1 可知，状态转移方程为：
$$
f_{i}=f_{i-1}+f_{i-2}
$$
初始条件为 $f_1=1,f_2=2$。伪代码如下

```plain
CountStep(n)
f[1] = 1, f[2] = 2
for i = 3 to n do
    f[i] = f[i - 1] + f[i - 2]
return f[n]
```

3\. 由状态转移方程，共有 $n$ 次转移，每次转移的复杂度为 $\mathcal{O}(1)$，所以整体时间复杂度为 $\mathcal{O}(n)$，空间复杂度也为 $\mathcal{O}(n)$。

> 实际上 $f$ 为 Fibonacci 数列，有 $\mathcal{O}(\log n)$ 的矩阵快速幂求法。

二、考虑三个字符串 $X,Y,Z$ 的最长公共子序列 $\text{LCS}(X,Y,Z)$。

1\. 寻找反例 $X,Y,Z$ 使得 $\text{LCS}(X,Y,Z)$ 不等于 $\text{LCS}(X,\text{LCS}(Y,Z))$。  
2\. 设计动态规划算法计算 $X,Y,Z$ 的最长公共子序列。 写出伪代码， 并分析算法的时间复杂度。

1\. 考虑 $X=\texttt{abcd},Y=\texttt{abcde},Z=\texttt{abced}$，那么 $\text{LCS}(X,Y,Z)=\texttt{abcd}$，但是 $\text{LCS}(Y,Z)=\texttt{abcd}$ 或 $\texttt{abce}$，因此 $\text{LCS}(X,Y,Z)\neq \text{LCS}(X,\text{LCS}(Y,Z))$。

2\. 类似 LCS 在两个串情况下的求法，优化子结构如下：设 $X=(x_1,\ldots,x_m),Y=(y_1,\ldots,y_n),Z=(z_1,\ldots,z_k)$，$\text{LCS}(X,Y,Z)=(l_1,\ldots,l_p)$ 是 $X,Y,Z$ 的最长公共子序列，有：

1. 如果 $x_m=y_n=z_k$，则 $l_p=x_m=y_n=z_k$，$\text{LCS}(X,Y,Z)=\text{LCS}(X_{m-1},Y_{n-1},Z_{k-1})+1$；
2. 如果不满足 $x_m=y_n=z_k$，且 $l_p\neq x_m$，则 $\text{LCS}(X,Y,Z)=\text{LCS}(X_{m-1},Y,Z)$；
3. 如果不满足 $x_m=y_n=z_k$，且 $l_p\neq y_n$，则 $\text{LCS}(X,Y,Z)=\text{LCS}(X,Y_{n-1},Z)$；
4. 如果不满足 $x_m=y_n=z_k$，且 $l_p\neq z_k$，则 $\text{LCS}(X,Y,Z)=\text{LCS}(X,Y,Z_{k-1})$；

对于 (1)，设 $l_p\neq x_m$，则可加 $x_m=y_n=z_k$ 到 $\text{LCS}(X,Y,Z)$，得到一个长为 $p+1$ 的最长公共子序列，与定义矛盾，所以 $l_p=x_m$。设存在 $X_{m-1},Y_{n-1},Z_{k-1}$ 的非最长公共子序列 $L_{p-1}$，使得 $\text{LCS}(X,Y,Z)=L_{p-1}+1$，则由于 $|L_{p-1}|<|\text{LCS}|$，$|L_{p-1}|+1<|\text{LCS}(X_{m-1},Y_{n-1},Z_{k-1})|+1$，与定义矛盾，所以 (1) 成立。

对于 (2)，由于 $l_p\neq x_m$，设存在 $X_{m-1},Y,Z$ 的最长公共子序列 $W$ 的长度大于 $p$，则 $W$ 也是 $X,Y,Z$ 的最长公共子序列长度，与定义矛盾。所以 (2) 成立。

对于 (3)，(4)，证明同 (2)。

因此令 $f_{i,j,k}$ 为 $X_i,Y_j,Z_k$ 的最长公共子序列长度，转移方程为

$$
f_{i,j,k}=
\begin{cases}
0 & ijk=0\\
f_{i-1,j-1,k-1}+1 & ijk\neq 0,X_i=Y_j=Z_k\\
\max\{f_{i-1,j,k},f_{i,j-1,k},f_{i,j,k-1}\} & \text{else}
\end{cases}
$$

伪代码如下：

```plain
LCS-length(X, Y, Z)
n = length(X), m = length(Y), l = length(Z)
for i = 0 to n do
    for j = 0 to m do
        for k = 0 to l do
            f[i, j, k] = 0
for i = 1 to n do
    for j = 1 to m do
        for k = 1 to l do
            if X[i] = Y[j] and Y[j] = Z[k] then
                f[i, j, k] = f[i - 1, j - 1, k - 1] + 1
                B[i, j, k] = 1
            else
                if f[i - 1, j, k] is max of {f[i - 1, j, k], f[i, j - 1, k], f[i, j, k - 1]} then
                    f[i, j, k] = f[i - 1, j, k]
                    B[i, j, k] = 2
                else if f[i, j - 1, k] is max of {f[i - 1, j, k], f[i, j - 1, k], f[i, j, k - 1]} then
                    f[i, j, k] = f[i, j - 1, k]
                    B[i, j, k] = 3
                else
                    f[i, j, k] = f[i, j, k - 1]
                    B[i, j, k] = 4
return f and B
Print-LCS(B, X, i, j, k)
if i = 0 or j = 0 or k = 0 then
    return
if B[i, j, k] = 1 then
    Print-LCS(B, X, i - 1, j - 1, k - 1)
    Print(X[i])
else if B[i, j, k] = 2 then
    Print-LCS(B, X, i - 1, j, k)
else if B[i, j, k] = 3 then
    Print-LCS(B, X, i, j - 1, k)
else
    Print-LCS(B, X, i, j, k - 1)
return
```

对于求最长公共子序列长度，可知有 $n^3$（$nml$）次转移，每次转移的复杂度为 $\mathcal{O}(1)$，所以整体的时间复杂度为 $\mathcal{O}(n^3)$（$\mathcal{O}(nml)$），空间复杂度为 $\mathcal{O}(n^3)$（$\mathcal{O}(nml)$）。

对于输出最长公共子序列，时间复杂度为 $\mathcal{O}(n)$（$\mathcal{O}(n+m+l)$），空间复杂度为 $\mathcal{O}(n^3)$（$\mathcal{O}(nml)$）。

三、给定一个 $m\times n$ 的网格，网格中全是非负的整数。找出一条从该网格左上角到右下角的路径，使得路径上数字总和最小。每次只能向下或者向右移动一步。

设 $f_{i,j}$ 表示从左上角到达 $(i,j)$ 的路径上的最小数字和。为了到达 $(i,j)$，可以从 $(i-1,j)$ 向下移动一步，或者从 $(i,j-1)$ 向右移动一步走到，转移方程可以写作

$$
f_{i,j}=
\begin{cases}
\min\{f_{i,j-1},f_{i-1,j}\}+a_{i,j} & i,j\ge 2\\
a_{i,j} & \text{else}
\end{cases}
$$

伪代码为

```plain
MinSum(n, m)
for i = 1 to n do
    f[i, 1] = f[i - 1, 1] + a[i, 1]
for i = 1 to m do
    f[1, i] = f[1, i - 1] + a[1, i]
for i = 2 to n do
    for j = 2 to m do
        f[i, j] = min(f[i, j - 1], f[i - 1, j]) + a[i, j]
return f[n, m]
```

可知时间复杂度为 $\mathcal{O}(nm)$，空间复杂度为 $\mathcal{O}(nm)$。

四、给定一个整数序列 $a_1,\ldots,a_n$。相邻两个整数可以合并，合并两个整数的代价是这两个整数之和。通过不断合并最终可以将整个序列合并成一个整数，整个过程的总代价是每次合并操作代价之和。试设计一个动态规划算法给出序列 $a_1,\ldots,a_n$ 的一个合并方案使得该方案的总代价最大。你的答案应包括：

1\. 用简明的语言表述这个问题的优化子结构。  
2\. 根据优化子结构写出代价方程。  
3\. 根据代价方程写出动态规划算法（伪代码）并分析算法的时间复杂性。

1\. 若计算 $a_1,\ldots,a_n$ 的最大合并代价，假设从 $k$ 处断开，则合并出 $a_1,\ldots,a_k$ 的子问题的解必为其优化解，合并出 $a_{k+1},\ldots,a_n$ 的子问题的解必为其优化解。

2\. 令 $f_{i,j}$ 为合并 $a_i,\ldots,a_j$ 的最大合并代价，则转移方程为

$$
f_{i,j}=
\begin{cases}
0 & i=j\\
\max_{i\le k<j}\{f_{i,k}+f_{k+1,j}+s(i,j)\} & i<j
\end{cases}
$$

其中 $s(i,j)=\sum_{k=i}^j a_k$。

3\. 伪代码如下

```plain
Merge(n)
for i = 1 to n do
    f[i, i] = 0
    s[i] = s[i - 1] + a[i]
for l = 2 to n do
    for i = 1 to n - l + 1 do
    j = i + l - 1
    f[i, j] = 0
    for k = i to j - 1 do
        f[i, j] = max{f[i, j], f[i, k] + f[k + 1, j] + s[j] - s[i - 1]}
return f[1, n]
```

根据伪代码，可知此算法时间复杂度为 $\mathcal{O}(n^3)$。

五、输入凸 $n$ 边形 $a_1,\ldots,a_n$ 其中顶点按凸多边形边界的逆时针序给出，多边形中不相邻顶点间的连线称为弦。试设计一个动态规划算法，将凸边形 $a_1,\ldots,a_n$ 剖分成一些无公共区域的三角形，使得所有三角形的周长之和最小。写出伪代码，并分析算法的时间复杂度。

设 $P=\{a_1,\ldots,a_n\}$ 是 $n$ 个顶点的多边形，如果 $T_P$ 是 $P$ 的包含三角形 $a_1a_ka_n$ 的优化三角剖分，即

$$
T_P=T(a_1,\ldots,a_k)\cup T(a_k,\ldots,a_n)\cup a_1a_ka_n
$$

则 $T(a_1,\ldots,a_k)$ 是 $P_1=\{a_1,\ldots,a_k\}$ 的最优三角剖分，则 $T(a_k,\ldots,a_n)$ 是 $P_1=\{a_k,\ldots,a_n\}$ 的最优三角剖分。

设 $f_{i,j}$ 为 $T(a_{i-1},\ldots,a_j)$ 这个优化三角剖分的代价，则

$$
f_{i,j}=
\begin{cases}
0 & i= j\\
\min_{i\le k<j}\{f_{i,k}+f_{k+1,j}+C_{a_{i-1}a_ja_k}\} & i<j
\end{cases}
$$

其中 $C_{a_{i-1}a_ja_k}$ 是三角形 $a_{i-1}a_ja_k$ 的周长。

伪代码如下

```plain
MinC(n)
for i = 0 to n do
    f[i, i] = 0
for l = 2 to n do
    for i = 2 to n - l + 1 do
    j = i + l - 1
    f[i, j] = infty
    for k = i to j - 1 do
        f[i, j] = min{f[i, j], f[i, k] + f[k + 1, j] + C(a[i - 1], a[j], a[k])}
return f[1, n]
```

由伪代码可知，时间复杂度为 $\mathcal{O}(n^3)$。

### 贪心算法

一、一棵树，结点个数为 $n$，根结点为 $r$。每个结点都有一个权值 $c_i$，开始时间为 $0$，每染色一个结点需要耗时 $1$，每个结点的染色代价为 $c_i\times t_i$（$t_i$ 为当前的时间），每个结点只有在父结点已经被染色的条件下才能被染色。求对整棵树完成染色需要花费的最小代价 $E$。

1\. 给出贪心策峈；  
2\. 证明贪心选择性和优化子结构；  
3\. 写出伪代码并分析算法复杂度。

1\. 考虑等价问题：求一个点的排列 $\{p_i\}$，满足对任意非根节点，父节点排在自己前面，排列的代价为 $\sum_{i=1}^n ic_{p_i}$，求最小代价。

由排序不等式，考虑让权值大的点排在前面，而在选这个权值最大的点前要先选父节点。考虑一个合法的排列 $p$，如果 $p_i$ 不是 $p_{i+1}$ 的父亲，且 $p_i$ 的权值比 $p_{i+1}$ 小，则由排序不等式，交换这两项结果更优。不断重复上述过程，可以发现权值最大的点一定紧跟在它的父节点后面。由此，考虑有两个集合 $S_1$ 和 $S_2$ 先后被染色，$S_1$ 和 $S_2$ 互不影响，这两个集合实际上为不相交的两棵子树。考虑先合并 $S_1$ 再合并 $S_2$ 为最优，则满足

$$
\sum_{i=1}^{|S_1|}ic_{s_{1i}}+\sum_{i=1}^{|S_2|}(i+|S_1|)c_{s_{2i}}<\sum_{i=1}^{|S_2|}ic_{s_{2i}}+\sum_{i=1}^{|S_1|}(i+|S_2|)c_{s_{1i}}
$$

化简后有

$$
\frac{\sum_{i=1}^{|S_1|}c_{s_{1i}}}{|S_1|}>\frac{\sum_{i=1}^{|S_2|}c_{s_{2i}}}{|S_2|}
$$

可以解释为：已经预合并了两段点 $S_1$ 和 $S_2$，$p$ 中先出现 $S_1$ 再出现 $S_2$ 当且仅当上式成立。

2\. 贪心选择性：第一次一定选择权值最大的点与父亲合并。如果不是，设权值最大的节点为 $p$，如果其为根节点，那么它一定在第一次合并，否则设其父亲为 $f$，则此时的代价为

$$
\ldots+ic_f+(i+1)c_x+\ldots+jc_p+\ldots
$$

交换 $c_x$ 和 $c_p$，不妨假设这次操作不影响 $x$ 染色的合法性，则代价为

$$
\ldots+ic_f+(i+1)c_p+\ldots+jc_x+\ldots
$$

由于 $c_p>c_x$ 且 $i+1>j$，则下式更小。因此第一次选择一定选择权值最大的点与父亲合并。

优化子结构：考虑已预合并的两端要合并起来，方法同 (1) 中说明。

3\. 伪代码如下

```plain
Color(n)
S = {}, ans = 0
for i = 1 to n do
    Insert(S, c[i])
while S is not empty do
    x = Extract-max(S)
    f = Tree-top(x)
    Union(x, f)
    Delete(S, f)
    ans += c[x] * siz[f]
    c[f] += c[x], siz[f] += siz[x]
    Insert(S, c[f] / siz[f])
return ans
```

首先将这些点插入平衡树中，时间复杂度为 $\mathcal{O}(n)$。然后不断取出预合并段权值和与大小比值最大的段，我们把一个预合并段的信息存在树上这个预合并段中深度最浅的节点，用并查集维护。我们把这个预合并段合并在最高点的父节点所在的预合并段上，假设这个预合并段的权值和为 $c_x$，则接在父节点后面会产生 $c_x\times \text{siz}_f$ 的贡献，将其计入答案，然后将下面段的信息合并到父节点所在的段上。

对于这棵平衡树，每次操作都减少一个元素，合并两预合并段的时间复杂度需要先进行平衡树上查询，再进行并查集的查询和合并，然后进行一次平衡树的权值修改（用一次删除和一次插入表示），时间复杂度为 $\mathcal{O}(\log n)$，因此整体复杂度为 $\mathcal{O}(n\log n)$。

> 实际上为 [POJ 2054](http://poj.org/problem?id=2054)，代码在[这里](https://github.com/HeRaNO/OI-ICPC-Codes/blob/master/POJ/POJ2054.cpp)

二、给定两个大小为 $n$ 的正整数集合 $A$ 和 $B$。对于 $A$ 到 $B$ 的一个一一映射 $f$，不妨设 $f(a_i) = b_i\ (i=1,2,\ldots,n)$，则 $f$ 的代价为 $\sum_{i=1}^n a_i^{b_i}$。试设计一个贪心算法，找出从 $A$ 到 $B$ 的代价最大的一一映射。

每次选择两集合中最大的 $a_i,b_i$，使 $f(a_i)=b_i$，这样得到的权值最大。

伪代码如下

```plain
MaxF(A, B)
n = Size(A)
sort(A), sort(B)
for i = 1 to n do
    f[a[i]] = b[i]
return f
```

首先我们分别对 $A$ 和 $B$ 排序，时间复杂度为 $\mathcal{O}(n\log n)$，然后遍历 $A$ 和 $B$ 中所有元素，时间复杂度为 $\mathcal{O}(n)$，因此整体复杂度为 $\mathcal{O}(n\log n)$。

正确性证明如下。

1\. 贪心选择性：对排序后（从大到小）的 $A,B$ 中元素分别表示为 $a_1,\ldots,a_n$ 和 $b_1,\ldots,b_n$，只需证优化解中存在 $f(a_1)=b_1$。

假设优化解中不存在 $f(a_1)=b_1$，而是 $f(a_1)=b_j,f(a_i)=b_1$，则此时，映射的代价为

$$
C=\sum_{k\neq 1,i}a_k^{b_k}+a_1^{b_j}+a_j^{b_1}
$$

而交换这两个映射，代价为

$$
C'=\sum_{k\neq 1,i}a_k^{b_k}+a_1^{b_1}+a_j^{b_j}
$$

考虑 $C-C'=a_1^{b_j}+a_j^{b_1}-a_1^{b_1}-a_j^{b_j}$，令 $g(x)=x^{b_1}-x^{b_j}$，则 $g'(x)=b_1x^{b_1-1}-b_jx^{b_j-1}$。由于 $b_1\ge b_j$，则有 $b_1x^{b_1-1}-b_jx^{b_j-1}\ge b_j(x^{b_1-1}-x^{b_j-1})$，而 $b_1,b_j$ 都是正整数，所以 $x^{b_1-1}\ge x^{b_j-1}$ 在 $x>0$ 时恒成立，因此 $g'(x)\ge 0$ 在 $x>0$ 时恒成立，$g(x)$ 单调不减。而 $a_1\ge a_i$，所以 $g(a_1)\ge g(a_i)$，即 $a_1^{b_1}-a_1^{b_j}\ge a_i^{b_1}-a_i^{b_j}$，因此 $C'\ge C$。

由以上，做一次交换不会使代价变劣，原假设不成立。因此优化解中存在 $f(a_1)=b_1$。

2\. 优化子结构：只需证 $f:f(a_i)=b_i\ (i\ge 2)$ 是问题 $A-\{a_1\},B-\{b_1\}$ 的优化解。若存在 $f':f(a_i)=b_j\ (i,j\ge 2)$ 是问题 $A-\{a_1\},B-\{b_1\}$ 的优化解，则 $C_{f'}>C_f$，而加上 $f(a_1)=b_1$ 的代价后，有 $C_{f'}+a_1^{b_1}>C_f+a_1^{b_1}$，这样又构造出了一个比原问题优化解更优的解，不成立。所以原命题得证。

综上，上述贪心算法的正确性得证。

三、给定平面点集 $P = \{(x_i,y_i)\mid 1\le i\le m\}$ 和 $Q = \{(x_j,y_j)\mid 1\le j\le n\}$。$(x_i, y_i)\in P$ 支配 $(x_j, y_j)\in Q$ 当且仅当 $x_i \ge x_j$ 且 $y_i\ge y_j$。试设计一个贪心算法输出集合 $\{(p,q)\mid p\in P,q\in Q\}$ 且 $p$ 支配 $q$，使得该集合中点对最多。

首先由于要输出集合，因此最差情况下不可避免遍历 $P,Q$ 中所有点，因此暴力枚举判断的复杂度即为复杂度上限。

至于贪心算法，本题可转化为：平面上目前已有点集 $Q$，而 $P$ 不在平面上。枚举 $P$ 中每个点 $p$，询问 $p$ 的左下方的所有点 $q$。这个过程是一个计数过程，不存在优化问题，因此无需贪心算法。

> 怎么改题意之后想都是一个计数问题，比如找左下方没有点的最大子集什么的，那直接二维偏序就好了。总感觉我和出题人总有一个题意挂了。

四、一个 DNA 序列 $X$ 是字符集 $\{\text{G},\text{T},\text{A},\text{C}\}$ 上的串，其上有大量信息冗余。设 $x$ 是 $X$ 的子串，$x$ 及其冗余形式在 $X$ 内在出现的起、止位置构成了一系列等长区间 $[p_1, q_1],\ldots,[p_m, q_m]$。试设计一个贪心算法找出 $\{[p_1, q_1],\ldots,[p_m, q_m]\}$ 的一个最大子集，要求子集中的区间两两不相交。

1\. 给出贪心策略；  
2\. 证明贪心选择性和优化子结构；  
3\. 写出伪代码并分析算法复杂度。

1\. 按右端点从小到大排序后枚举每个区间，先将第一个区间加入几何，然后只要当前区间左端点在集合中最后一个区间的右端点右边，就选择这个区间加入集合。

2\. 贪心选择性：设 $S$ 是一个优化解，按结束位置排序这些区间，设第一个区间为 $k$，第二个区间为 $j$。如果 $k=1$，则命题成立，若 $k\neq 1$，令 $S'=S-\{k\}\cup \{1\}$，由于 $S$ 中的区间互不相交，且 $q_1<q_k<q_j$，则 $S'$ 中的区间也互不相交，则 $|S'|=|S|$，所以 $S'$ 也是一个优化解，且包含区间 $1$。

优化子结构：设 $A$ 是一个包含 $\{1\}$ 的优化解。则 $A'=A-\{1\}$ 是问题 $I'=\{i\in I\mid p_i>q_1\}$ 的优化解。显然 $A'$ 中区间互不相交，只需证 $A'$ 是最大的。若不然，则存在一个 $I'$ 的问题优化解 $B'$，且 $|B'|>|A'|$，令 $B=\{1\}\cup B'$，对于任意 $i\in I'$，都有 $p_i>q_1$，所以插入后 $B$ 中区间也是互不相交的，则 $B$ 是 $I$ 的一个解。由于 $|A|=|A'|+1$，则 $|B|=|B'|+1>|A'|+1=|A|$，因此与 $A$ 为最大矛盾，因此此问题具有优化子结构。

3\. 伪代码

```plain
IntervalSelect(P, Q)
sort(P, Q)
S = {1}
j = 1
for i = 2 to n do
    if P[i] > Q[j] then
        Append(S, i)
        j = i
return S
```

首先对线段按照右端点从小到大排序，时间复杂度为 $\mathcal{O}(n\log n)$，之后枚举每条线段，时间复杂度为 $\mathcal{O}(n)$。因此整体时间复杂度为 $\mathcal{O}(n\log n)$。

五、某工厂收到 $n$ 个订单 $(a_i, b_i)\ (1\le i\le n)$，其中 $a_i$ 和 $b_i$ 均是正整数，订单 $(a_i, b_i)$ 希望在时间 $b_i$ 之前获得 $a_i$ 件产品。工厂的生产能力为每个时间单位生产 $1$ 件产品。工厂希望拒绝最少数量的订单，并恰当地排序剩下的订单使得剩下的订单均能够被满足。试设计一个贪心算法求解上述问题。

首先排除一定不能完成的订单，即 $b_i<a_i$ 的订单。排除后按 $a_i$ 从小到大排序，之后枚举每个订单，如果这个订单可以完成，则加入可满足的订单列表，否则拒绝它。

贪心选择性：考虑 $S$ 是一个优化解，设第一个订单为 $(a_k,b_k)$，第二个订单为 $(a_j,b_j)$。若 $k=1$ 则命题成立，若 $k\neq 1$，令 $S'=S-\{(a_k,b_k)\}\cup \{(a_1,b_1)\}$，由于 $a_1<a_k<a_j$，不妨设 $b_k<b_j$，则 $a_k\le b_k,a_k+a_j\le b_j$，则将 $(a_k,b_k)$ 换为 $(a_1,b_1)$，有 $a_1+a_j<a_k+a_j\le b_j$，因此这种交换合法，且 $|S'|=|S|$，则 $S'$ 也是一个优化解，且包含 $(a_1,b_1)$。

优化子结构：设 $A$ 是包含 $\{(a_1,b_1)\}$ 的优化解，则 $A'=A-\{(a_1,b_1)\}$ 为剩余问题的优化解。若不然，则存在优化解 $B'$，满足 $|B'|>|A'|$，令 $B=\{(a_1,b_1)\}\cup B'$，由于剩余问题中保持了 $\{(a_1,b_1)\}$ 的产能，所以插入后 $B$ 中所有订单都可以生产，则 $B$ 是一个解。由于 $|A|=|A'|+1$，则 $|B|=|B'|+1>|A'|+1=|A|$，因此与 $A$ 为最大矛盾，因此此问题具有优化子结构。

伪代码如下

```plain
MinReject(n, a, b)
sort(a, b)
accept = {}
for i = 1 to n do
    if b[i] > a[i]
        continue
    Insert(accept, (a[i], b[i]))
    cnt = 0
    valid = true
    for task in accept do
        cnt += task.a
        if cnt > task.b then
            valid = false
            break
    if valid = false then
        Delete(accept, (a[i], b[i]))
return accept
```

由伪代码，排序的复杂度为 $\mathcal{O}(n\log n)$。维护一棵平衡树，以 $b_i$ 从小到大的顺序维护。之后遍历每个任务，首先插入这个任务，之后遍历平衡树中元素，检查目前接受的订单是否都能完成，如果不能完成，则跳出循环，并删除这个元素，检查过程中复杂度为 $\mathcal{O}(n)$。最后返回这棵平衡树。整体时间复杂度为 $\mathcal{O}(n^2)$。

六、有 $n$ 个石子，每个石子的重量为 $w_i$，现将其聚集成一堆，要求每次只能操作两堆进行合并，每次操作的代价是操作石子重量的和，那么请设计一个方案使聚集的总代价 $E$ 最小。

1\. 给出贪心策略；  
2\. 证明贪心选择性和优化子结构；  
3\. 写出伪代码并分析算法复杂度。

1\. 每次选择重量最小的两堆石子 $x,y$ 合并为一堆。

2\. 贪心选择性：考虑合并过程中形成的二叉树，若第一次合并未选择重量最小的两个石子，而将其中一个换为 $w_p>w_y$ 的石子，那么这次交换将带来 $-w_yd_y+w_pd_y-w_pd_p+w_pd_y$ 的贡献。由于先合并会带来更多的合并轮次，因此 $d_p\le d_y$，所以贡献为 $(d_y-d_p)(w_p-w_y)\ge 0$，因此交换可能带来更大的代价，所以按重量最小的两堆合并得到的代价是最小的。

最优子结构：设 $A$ 是第一步合并重量最小的两堆石子的优化解，则 $A'=A-\{x,y\}\cup \{x+y\}$ 是剩余问题的优化解。若不然，则将这个优化解并上第一步将获得更小的代价，与假设矛盾。

3\. 伪代码如下

```plain
MergeStone(W)
n = |W|, Q <- W 且 Q 是小顶堆, ans = 0
for i = 1 to n - 1 do
    x = Extract-min(Q)
    y = Extract-min(Q)
    ans += x + y
    Insert(Q, x + y)
return ans
```

首先构建小顶堆的复杂度为 $\mathcal{O}(n)$，然后每次循环取得最小值和插入堆的时间复杂度为 $\mathcal{O}(\log n)$，因此整体时间复杂度为 $\mathcal{O}(n\log n)$。

## 第三次作业

一、在下图中考虑哈密顿环问题。将问题的解空间表示成树，并分别利用深度优先搜索和广度优先搜索判定该图是否存在哈密顿环。

![](/images/algorithm-homework/f.3.1.png)

首先要画搜索树，但是搜索树太大了，自己画吧。

使用深度优先搜索，伪代码如下：

```plain
DFS(G)
1. 构造由 {1} 组成的单元素栈 S
2. If Top(S) 的长度为 8 Then 输出 Top(S)，停止
3. Else T = Top(S), Pop(S)
4, 将每个与 T 的最后一个元素相连，且不在 T 中的元素（除 1 以外）加入 T，压入 S
5. Goto 2
6. If S 空 Then 无解
```

使用广度有限搜索伪代码如下：

```plain
BFS(G)
1. 构造由 {1} 组成的单元素队列 Q
2. If Q 的首元素长度为 8 Then 输出首元素，停止
3. Else T = Q 的首元素, 弹出 T
4. 将每个与 T 的最后一个元素相连，且不在 T 中的元素（除 1 以外）加入 T，加入 Q
5. Goto 2
6. If Q 空 Then 无解
```

二、考虑 8-魔方问题。分别用爬山法，最佳优先方法判定上图所示的初始格局能够通过一系列操作转换成目标格局，将搜索过程的主要步骤书写清楚。

![](/images/algorithm-homework/f.3.2.png)

> 话说这玩意不叫八数码吗……

使用爬山法，令启发式测度函数 $f(n)=W(n)$，其中 $W(n)$ 是节点 $n$ 中处于错误位置的方块数，扩展结点时，按 $W(n)$ 从大到小的顺序压栈，让 $f(n)$ 小的节点先扩展。伪代码如下：

```plain
1. 构造由初始局面组成的单元素栈 S
2. If Top(S) 是目标局面 Then 停止
3. Pop(S)
4. 对于 Top(S) 的所有可能移动，按新局面 f(n) 从大到小的顺序压入 S
5. If S 空 Then 无解 Else goto 2 
```

使用最佳优先方法，根据评价函数 $f(n)$，在目前产生的所有节点中选择具有最小评价函数值的节点进行扩展。伪代码如下：

```plain
1. 使用评价函数构造小根堆 H，将初始局面插入 H 中
2. If H 的根 r 是目标局面 Then 停止
3. 从 H 中删除 r，将 r 移动后所有可能的局面插入 H
4. If H 空 Then 无解 Else goto 2 
```

三、精确描述求解 8-魔方问题的 A* 算法，在习题 2 给出了起始格局和目标格局上给出 算法操作的主要步骤。

1\. 设计 $g(n)$，$h*(n)$，$h(n)$ 和 $f(n)$，以满足 A* 算法的要求；  
2\. 以第 2 题给出的起始和目标格局，写出 A* 算法运行的主要步骤，并标明每一步 $h(n)$，$f(n)$ 的值。

1\. 令 $g(n)$ 为从初始局面变为局面 $n$ 所经历的步数，$h(n)$ 为局面 $n$ 与目标局面之间，相同数码在两个棋盘中的曼哈顿距离之和，$h*(n)$ 为从局面 $n$ 到目标局面经历的步数，$f(n)=g(n)+h(n)$。

2\. 过程如下。

```plain
    2 3 0
    1 8 5
    7 4 6

1.  2 0 3             2 3 5
    1 8 5 g(n) = 1    1 8 0 g(n) = 1
    7 4 6 h(n) = 7    7 4 6 h(n) = 10

2.  0 2 3             2 8 3
    1 8 5 g(n) = 2    1 0 5 g(n) = 2
    7 4 6 h(n) = 6    7 4 6 h(n) = 8

3.  1 2 3
    0 8 5 g(n) = 3
    7 4 6 h(n) = 5

4.  1 2 3             1 2 3
    8 0 5 g(n) = 4    7 8 5 g(n) = 4
    7 4 6 h(n) = 4    0 4 6 h(n) = 6

5.  1 2 3             1 2 3
    8 4 5 g(n) = 5    8 5 0 g(n) = 5
    7 0 6 h(n) = 3    7 4 6 h(n) = 5

6.  1 2 3             1 2 3
    8 4 5 g(n) = 6    8 4 5 g(n) = 6
    7 6 0 h(n) = 2    0 7 6 h(n) = 4

7.  1 2 3
    8 4 0 g(n) = 7
    7 6 5 h(n) = 1

8.  1 2 3
    8 0 4 g(n) = 8
    7 6 5 h(n) = 0
```

四、分别使用深度优先法和分支限界法求解子集和问题的如下实例。

输入：集合 $S=\{7,4,6,13,20,8\}$ 和整数 $K=18$。  
输出：$S'\subseteq S$ 使得 $S'$ 中元素之和等于 $K$。

使用深度优先搜索伪代码如下：

```plain
1. 构造由空集组成的单元素栈 S
2. If Top(S) 的集合元素和为 K Then 停止
3. 令 C = Top(S), Pop(S)
4. 对于每个不在 C 中的元素 x，C <- C ∪ {x}，将 C 压入 S
5. If S 空 Then 无解 Else goto 2
```

使用分支界限法可以缩小解空间的范围，伪代码如下：

```plain
1. 构造由空集组成的单元素栈 S
2. If Top(S) 的集合元素和为 K Then 停止
3. 令 C = Top(S), Pop(S)
4. 对于每个不在 C 中的元素 x，如果加入 C 后集合元素和仍
   小于等于 K，则 C <- C ∪ {x}，将 C 压入 S
5. If S 空 Then 无解 Else goto 2
```

五、利用搜索求下图的最大完全子图（团），要求写出计算过程。

![](/images/algorithm-homework/f.3.5.png)

抄一下 [Bron–Kerbosch Algorithm](https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm)。

## 第四次作业

### 随机算法

一、一个木桶里有 $M$ 个白球，每分钟从桶里随机取一个球涂成红色（无论白球或红球都涂红）再放回，问将桶中的球全部涂红的期望时间是多少？

令 $E(i)$ 表示木桶里有 $i$ 个红球时，还需要抽取直到可以将所有球都染成红色的期望时间。对于当前状态，$E(i)$ 的计算可以分为两部分：此时抽到红球和此时抽到白球。此时抽到红球的概率为 $\frac{i}{M}$，抽到白球的概率为 $1-\frac{i}{M}$，所以可知

$$
E(i)=\frac{i}{M}(E(i)+1)+(1-\frac{i}{M})(E(i+1)+1)
$$

化简可得

$$
E(i)=E(i+1)+\frac{M}{M-i}
$$

由已知，$E(M)=0$，则根据归纳法可知

$$
E(0)=0+\frac{M}{1}+\frac{M}{2}+\ldots+1=M\sum_{i=1}^M\frac{1}{i}
$$

二、传送带上有若干产品，一个质量检测员在传送带某一检测点工作，如果他今天要检测 $k$ 个产品：

1\. 请帮他设计一个检测算法，使得整条传送带上的所有产品被选中的概率相同。  
2\. 证明该算法使得所有产品被选中的概率相同。

1\. 首先取走传送带上前 $k$ 个产品，放在待检区。对于后续产品 $i$，生成一个 $1$ 到 $i$ 的随机数 $j$，如果 $j\le k$，则将待检区中第 $j$ 个产品替换为产品 $i$，否则忽略产品 $i$。

等到所有产品都通过后，待检区内的产品就是要检测的产品。

2\. 要证：对于传送带上前 $i\ (i\ge k)$ 个产品，其被抽取的概率均为 $\frac{k}{i}$。

使用归纳法。当 $i=k$ 时，前 $k$ 个产品均被直接抽取，概率为 $1$。

当第 $i+1$ 个产品到来时，这个产品被抽取的概率为 $\frac{k}{i+1}$。假设前 $i$ 个产品任意一个被抽取的概率均为 $\frac{k}{i}$，待检区的 $k$ 个产品中，仍被保留的概率为 $\frac{k}{i}\times(1-\frac{1}{i+1})=\frac{k}{i+1}$，因此新产品通过后，前 $i+1$ 个产品被抽取的概率为 $\frac{k}{i+1}$，符合假设。因此根据数学归纳法，假设成立，上述算法使得所有产品被选中的概率相同。

> [Reservoir sampling - Wikipedia](https://en.wikipedia.org/wiki/Reservoir_sampling)

### 近似算法

一、试着修改集合覆盖算法求解加权集合覆盖问题，并分析它的近似比。

可以参考 [Encyclopedia of Algorithms](https://dx.doi.org/10.1007/978-0-387-30162-4_175) 和 [UW CSE 525](https://courses.cs.washington.edu/courses/cse525/13sp/scribe/lec4.pdf)，写得都挺好的，翻译一下就好了。

二、考虑下述场景。给定一个城市集合以及城市之间的距离，从中需要选出 $k$ 个城市来设置仓库，使得各个城市距离它最近的仓库的距离中的最大者达到最小。这是经典的 K-center 问题，它的形式化定义如下：

输入：平面上的点集 $P$，欧式距离 $d(\cdot, \cdot)$，以及参数 $k$。  
输出：定义 $S\subseteq P$ 的代价是 $\text{cost}(S)=\max_{p\in P}\min_{s\in S} d(s,p)$。要求找到 $S$，使得 $\text{cost}(S)$ 最小。

下面是一个求解 K-center 问题的基于贪心策略的近似算法，请证明它的近似比是 $2$。

![](/images/algorithm-homework/f.4.1.png)

可以参考 [Metric k-center - Wikipedia](https://en.wikipedia.org/wiki/Metric_k-center) 和 [Geometric Approximation Algorithms Chap. 4.2](http://goo.gl/pLiEO)。

书里的反证法很巧妙。

### 在线算法

一、已知有 $n$ 个顶点的图，每条边分配一个正的边长。令在 $k\ (k<n)$ 个顶点分配 $k$ 名服务员去完成顶点处的请求。对一个请求的服务代价是满足该请求服务员移动的总距离。参见如图所示，有三名服务员 $s_1,s_2,s_3$，分别位于 $a$、$e$ 和 $g$，如果在顶点 $i$ 有一个请求，由于 $e$ 靠近 $i$，那么可能的一种移动方法是把位于顶点 $e$ 处的 $s_2$ 移动到顶点 $i$ 处，代价为 $e$ 到 $i$ 的边长。现在对服务员的请求序列是在线不断提供的，现需要获得全部请求序列最小服务代价。请设计一个在线算法计算最小服务代价并分析竞争比。

![](/images/algorithm-homework/f.4.2.png)

是一个 [k-server problem](https://en.wikipedia.org/wiki/K-server_problem)，题面就是 Introduction to the Design and Analysis of Algorithms 书里 12.2 节的例子，书在 Z-lib 能下到，注意作者是 R. C. T. Lee，并且书也挺老了，别下错了。但是看证明过程还是看 On-line Computation and Competitive Analysis 10.4 节的，写得很明白。

[原论文](https://dl.acm.org/doi/10.1145/62212.62243)中要求是完全图，但是一般图也是符合三角不等式的，考虑在最短路树上走就可以了。其实也可以直接看 [An Optimal On-Line Algorithm for K Servers on Trees](https://doi.org/10.1137/0220008) 这篇论文。

## 期末考试

考试考得贼小丑，虽然考试大部分还是作业里的，但是考前没看，哈哈。

先上来考的求时间复杂度，反正递推一下就行，一个主定理也不难。

然后是一个求哈密顿圈的分支界限搜索，要画搜索树，反正也就那么画。

然后是一个贪心，给了 $n$ 个区间，保证可以覆盖 $[1,n]$，问最少要多少区间才能覆盖 $[1,n]$。是 [LOJ #10002](https://loj.ac/p/10002)，在考场上纠结怎么排序，笑死。

然后是一个 DP，求最大子段和，随便搞搞就行了。

随机算法考的蓄水池抽样，但是要抽连续 $k$ 个，我不会。

近似算法考的是一般图最小权覆盖的近似算法，就在 PPT 上但是我没看，近似比 $2$ 我写了个 $\ln n$……
