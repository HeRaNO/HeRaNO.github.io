---
title: 「HLOI2015」Tree
categories: 'OI/ICPC'
date: 2016-05-02 17:02:49
tags:
	- HLOI
	- 线段树
	- DFS 序
	- 矩阵
toc: true
description: HLOI 2015 Day1 T3
---

## 题目描述
Chavo 有一颗水晶树，树上会结出魔法水晶。包括树根在内，树一共有 $n$ 个分叉的节点，其中 $1$ 号节点为树根，初始状态下每一个节点都有一个生长值 $a_i$。Chavo 有一根法杖，法杖可以对某个节点 $u$ 释放生长法术，使得以 $u$ 为根的子树的每个节点的生长值更新为 $f(k)$。对于每一个被更新的节点来说，$f(x)$ 的定义都不一样，其中 $f(1)$ 是在释放法术之前被更新节点的生长值，$f(2)$ 是在释放法术之前节点 $v$ 的生长值。但是对于所有被更新的节点来说，$f(x)$ 的递推公式都一样，是 $f(x)=f(x-1)+f(x-2)+k$。

Chavo 想要释放 $m$ 次生长法术，每次法术都给定 $u,\ v,\ k$，她想问问你释放法术之后所有节点的生长值的和是多少？结果要对 $10^9+7$ 取模后输出。

## 输入
第一行输入整数 $n$ 和 $m$；

第二行输入 $n$ 个整数，第 $i$ 个整数代表第 $i$ 个节点上初始值 $a_i$；

接下来 $n-1$ 行，每一行有两个正整数 $i,\ j$，代表树上第 $i$ 个节点和第 $j$ 个节点有树杈相连；

接下来 $m$ 行，每一行有 $3$ 个正整数 $u,\ v,\ k$，如题目描述。

## 输出
输出一个整数代表经过所有操作后整棵树上所有节点数的和，结果要对 $10^9+7$ 取模后输出。

## 样例输入
```plain
3 2
3 4 5
1 2
1 3
1 2 2
2 3 3
```
## 样例输出
```plain
19
```
## 样例说明
第一次操作时，更新 $1,\ 2,\ 3$ 号点，对于 $1$ 号点，$f(1)=3,\ f(2)=4$，更新后 $1$ 号点值为 $f(2)=4$，同理 $2,\ 3$ 号点值为 $4$。

第二次操作时，更新 $2$ 号点，$f(1)=4,\ f(2)=4,\ f(3)=11$，更新后 $2$ 号点为 $11$。

最后求和为 $4+11+4=19$。

## 数据范围及约定
对于 $30\%$ 的数据，$1\le n,m,k\le 100,1\le u,v,i,j\le n,0\le a_i\le 100$；

对于 $60\%$ 的数据，$1\le n,m\le 10^3,1\le k\le 10^9,1\le u,v,i,j\le n,0\le a_i\le 10^9$；

对于 $100\%$ 的数据，$1\le n,m\le 10^5,1\le k\le 10^9,1\le u,v,i,j\le n,0\le a_i\le 10^9$。

## 时间限制与空间限制

时间限制：$2000\text{ms}$，空间限制：$128\text{MB}$。

## 题解

### 推式子

注意，$f(1)$ 是对于子树内每个点说的……每个点的 $f(1)$ 不一定相同，不过都是该点的权值。

树上实现子树修改和查询，搞出来个 DFS 序就变成了区间问题，线段树即可解决。

但是这什么~~鬼畜~~修改。这个类似于斐波那契数列的递推关系。
先看看 $f(x)$ 的一些值有什么规律：

$$
\begin{align}
f(1)&=u\\
f(2)&=v\\
f(3)&=u+v+k\\
f(4)&=u+2v+k\\
f(5)&=2u+3v+4k\\
f(6)&=3u+5v+7k\\
f(7)&=5u+8v+12k\\
\dots
\end{align}
$$

如果我们定义一个类斐波那契数列 $F_i$，$F_{-1}=1,F_0=0,F_1=1$，$F_i=F_{i-1}+F_{i-2}\ (i>1)$，$f(n)$ 就可以这样描述了：

$$
f(n)=F_{n-2}u+F_{n-1}v+(F_n-1)k
$$

那么就可以想到如下两种算法。

### 算法一
注意到修改可以分为两部分，是给这个点的子树内所有节点的权值先乘上 $F_{n-2}$，再加上 $F_{n-1}v+(F_n-1)k$。于是先做一个区间乘法，然后利用矩阵算出要加的部分，最后做一个区间加法即可。

时间复杂度为 $\mathcal{O}(m(\log n+\log k))$，空间复杂度为 $\mathcal{O}(n)$。

### 算法二
算法一中，需要区间乘，区间加，区间覆盖，虽然很快但不好敲代码（好吧我承认其实也挺好写的……），所以考虑用一个矩阵乘法完成所有操作。

线段树中叶子节点维护的矩阵 $S$ 这样构造：

$$
S=
\begin{bmatrix}
u&0&1\\
0&0&0\\
0&0&0\\
\end{bmatrix}
$$

其中，$u$ 为此时这个节点的的权值，线段树上非叶子节点维护的都是单位矩阵，方便之后下传矩阵。

每次修改需要乘的矩阵 $T$ 是两个矩阵的乘积：

$$
T=
\begin{bmatrix}
1&0&0\\
0&0&0\\
0&v&1\\
\end{bmatrix}
\times
\begin{bmatrix}
0&1&0\\
1&1&0\\
0&k&1\\
\end{bmatrix}
^{k-1}
$$

其中，$v$ 是节点 $v$ 的生长值，$k$ 意义与题中相同。

那么这么乘能乘出来些什么？

为了方便，令：

$$
A=
\begin{bmatrix}
0&1&1\\
1&1&0\\
0&k&1\\
\end{bmatrix}
,B=
\begin{bmatrix}
1&0&0\\
0&0&0\\
0&v&1\\
\end{bmatrix}
$$

发现 $A^c$ 这个矩阵是这样的：

$$
A^c=
\begin{bmatrix}
F_{c-1}&F_c&0\\
F_c&F_{c+1}&0\\
(F_{c+1}-1)k&(F_{c+2}-1)k&1\\
\end{bmatrix}
$$

那么，$A^{k-1}$ 就是这样的：

$$
A^{k-1}=
\begin{bmatrix}
F_{k-2}&F_{k-1}&0\\
F_{k-1}&F_{k}&0\\
(F_k-1)k&(F_{k+1}-1)k&1\\
\end{bmatrix}
$$

$B\times A^{k-1}$ 是这样的：

$$
B\times A^{k-1}=
\begin{bmatrix}
F_{k-2}&F_{k-1}&0\\
0&0&0\\
vF_{k-1}+(F_k-1)k&vF_k+(F_{k+1}-1)k&1\\
\end{bmatrix}
$$

更新一个节点后，矩阵就是这样的：

$$
S\times B\times A^{k-1}=
\begin{bmatrix}
uF_{k-2}+vF_{k-1}+(F_k-1)k&uF_{k-1}+vF_k+(F_{k+1}-1)k&1\\
0&0&0\\
0&0&0\\
\end{bmatrix}
$$

$u$ 的位置顺利被 $f(k)$ 替代，构造成功。

那么，如何更新答案？

对于线段树矩阵，更新一个区间时 $S$ 矩阵乘 $T$，每次查询节点 $v$ 的生长值时，将这一区间矩阵下传，之后清为单位矩阵。

最后，将线段树上非叶子节点全部下传清为单位矩阵后，统计答案。即将矩阵中的 $u$ 加起来。

时间复杂度为 $\mathcal{O}(m(\log n+\log k))$，空间复杂度为 $\mathcal{O}(n)$。

代码见[这里](https://github.com/HeRaNO/OI-ICPC-Codes/blob/master/HSAHRBNUOJ/P20xx/P2075.cpp)。
